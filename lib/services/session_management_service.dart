import '../config/supabase_config.dart';

class SessionManagementService {
  /// Remove todas as sess√µes existentes de um jogo
  static Future<int> removeAllGameSessions(String gameId) async {
    try {
      print('üóëÔ∏è Removendo sess√µes existentes do jogo $gameId...');

      // Primeiro, contar quantas sess√µes ser√£o removidas
      final countResponse = await SupabaseConfig.client
          .from('game_sessions')
          .select('id')
          .eq('game_id', gameId);

      final sessionCount = countResponse.length;

      if (sessionCount == 0) {
        print('‚ÑπÔ∏è Nenhuma sess√£o encontrada para remover');
        return 0;
      }

      // Remover todas as sess√µes
      await SupabaseConfig.client
          .from('game_sessions')
          .delete()
          .eq('game_id', gameId);

      print('‚úÖ Removidas $sessionCount sess√µes do jogo $gameId');
      return sessionCount;
    } catch (e) {
      print('‚ùå Erro ao remover sess√µes: $e');
      rethrow;
    }
  }

  /// Remove apenas as sess√µes futuras de um jogo (mant√©m o hist√≥rico)
  static Future<int> removeFutureGameSessions(String gameId) async {
    try {
      print('üóëÔ∏è Removendo sess√µes futuras do jogo $gameId...');

      // Obter data atual para filtrar apenas sess√µes futuras
      final today = DateTime.now();
      final todayString = _formatDate(today);

      print('üîç Data atual para filtro: $todayString');

      // Primeiro, contar quantas sess√µes futuras ser√£o removidas
      final countResponse = await SupabaseConfig.client
          .from('game_sessions')
          .select('id, session_date')
          .eq('game_id', gameId)
          .gte('session_date', todayString);

      final sessionCount = countResponse.length;

      if (sessionCount == 0) {
        print('‚ÑπÔ∏è Nenhuma sess√£o futura encontrada para remover');
        return 0;
      }

      // Log das sess√µes que ser√£o removidas
      for (var session in countResponse) {
        print('   üìÖ Sess√£o futura a ser removida: ${session['session_date']}');
      }

      // Remover apenas as sess√µes futuras
      await SupabaseConfig.client
          .from('game_sessions')
          .delete()
          .eq('game_id', gameId)
          .gte('session_date', todayString);

      print('‚úÖ Removidas $sessionCount sess√µes futuras do jogo $gameId');
      print('üìö Hist√≥rico de sess√µes passadas foi preservado');
      return sessionCount;
    } catch (e) {
      print('‚ùå Erro ao remover sess√µes futuras: $e');
      rethrow;
    }
  }

  /// Cria novas sess√µes baseadas nas configura√ß√µes do jogo
  static Future<List<Map<String, dynamic>>> createNewSessions(
      Map<String, dynamic> gameData) async {
    try {
      print(
          'üìÖ Criando novas sess√µes para jogo com frequ√™ncia: ${gameData['frequency']}');

      // Verificar se o jogo n√£o est√° deletado
      if (gameData['id'] != null) {
        final gameStatus = await _getGameStatus(gameData['id']);
        if (gameStatus == 'deleted') {
          print('‚ùå N√£o √© poss√≠vel criar sess√µes para um jogo deletado');
          throw Exception(
              'N√£o √© poss√≠vel criar sess√µes para um jogo que foi deletado');
        }
      }

      final String frequency = gameData['frequency'] ?? 'Jogo Avulso';

      // Se for jogo avulso, criar apenas uma sess√£o
      if (frequency == 'Jogo Avulso') {
        return await _createSingleSession(gameData);
      }

      // Para jogos com frequ√™ncia, criar m√∫ltiplas sess√µes
      return await _createRecurringSessions(gameData);
    } catch (e) {
      print('‚ùå Erro ao criar novas sess√µes: $e');
      rethrow;
    }
  }

  /// Cria uma sess√£o √∫nica (jogo avulso)
  static Future<List<Map<String, dynamic>>> _createSingleSession(
      Map<String, dynamic> gameData) async {
    try {
      final sessionData = {
        'game_id': gameData['id'],
        'session_date': gameData['game_date'] ?? _formatDate(DateTime.now()),
        'start_time': gameData['start_time'],
        'end_time': gameData['end_time'],
        'status': 'active'
      };

      final response = await SupabaseConfig.client
          .from('game_sessions')
          .insert([sessionData]).select();

      print('‚úÖ Sess√£o avulsa criada: ${response.first['id']}');
      return response;
    } catch (e) {
      print('‚ùå Erro ao criar sess√£o avulsa: $e');
      rethrow;
    }
  }

  /// Cria sess√µes recorrentes baseadas na frequ√™ncia
  static Future<List<Map<String, dynamic>>> _createRecurringSessions(
      Map<String, dynamic> gameData) async {
    try {
      final dayOfWeek = _getDayOfWeekNumber(gameData['day_of_week']);
      final frequency = gameData['frequency'];

      // Calcular a pr√≥xima data v√°lida baseada na data de cria√ß√£o do jogo e no dia da semana
      final gameCreationDate = gameData['created_at'] != null
          ? DateTime.parse(gameData['created_at'])
          : null;
      final currentDate = _calculateNextValidDate(dayOfWeek,
          gameCreationDate: gameCreationDate);

      print(
          'üìÖ Pr√≥xima data v√°lida calculada: ${_formatDate(currentDate)} (${_getDayName(dayOfWeek)})');

      final sessions = <Map<String, dynamic>>[];

      // Verificar se h√° data final definida
      DateTime? endDate;
      if (gameData['end_date'] != null) {
        endDate = DateTime.parse(gameData['end_date']);
        print('üìÖ Data limite definida: ${_formatDate(endDate)}');

        // Validar se a data limite n√£o √© anterior √† data atual
        if (endDate.isBefore(currentDate)) {
          print(
              '‚ö†Ô∏è Data limite ${_formatDate(endDate)} √© anterior √† data de in√≠cio ${_formatDate(currentDate)}');
          // Ajustar a data limite para ser pelo menos a data atual
          endDate = currentDate;
          print('üìÖ Data limite ajustada para: ${_formatDate(endDate)}');
        }

        // Validar se a data limite √© muito pr√≥xima da data atual
        final daysDifference = endDate.difference(currentDate).inDays;
        if (daysDifference < 1) {
          print(
              '‚ö†Ô∏è Data limite muito pr√≥xima da data atual - apenas 1 sess√£o ser√° criada');
        }
      } else {
        print('‚ö†Ô∏è Nenhuma data limite definida - usando valores padr√£o');
      }

      final maxSessions = _getMaxSessionsForFrequency(frequency,
          endDate: endDate, startDate: currentDate);

      print('üìä M√°ximo de sess√µes calculado: $maxSessions');

      // Criar sess√µes baseadas na frequ√™ncia
      DateTime sessionDate = currentDate;
      int sessionsCreated = 0;

      for (int i = 0; i < maxSessions; i++) {
        // Parar se a data da sess√£o ultrapassar a data final
        if (endDate != null && sessionDate.isAfter(endDate)) {
          print(
              'üõë Parando cria√ß√£o de sess√µes: data ${_formatDate(sessionDate)} ultrapassa data limite ${_formatDate(endDate)}');
          break;
        }

        // Log quando chegamos √† data final
        if (endDate != null &&
            sessionDate.year == endDate.year &&
            sessionDate.month == endDate.month &&
            sessionDate.day == endDate.day) {
          print(
              'üìÖ √öltima sess√£o criada para a data limite: ${_formatDate(sessionDate)}');
        }

        sessions.add({
          'game_id': gameData['id'],
          'session_date': _formatDate(sessionDate),
          'start_time': gameData['start_time'],
          'end_time': gameData['end_time'],
          'status': 'active'
        });

        sessionsCreated++;
        print(
            'üìÖ Sess√£o $sessionsCreated criada para: ${_formatDate(sessionDate)}');

        // Calcular pr√≥xima data baseada na frequ√™ncia
        sessionDate = _calculateNextDate(sessionDate, frequency);

        // Verificar se a pr√≥xima data ultrapassaria a data limite
        if (endDate != null && sessionDate.isAfter(endDate)) {
          print(
              'üõë Pr√≥xima data ${_formatDate(sessionDate)} ultrapassaria data limite ${_formatDate(endDate)} - parando cria√ß√£o');
          break;
        }
      }

      // Validar se pelo menos uma sess√£o foi criada
      if (sessionsCreated == 0) {
        print(
            '‚ö†Ô∏è Nenhuma sess√£o foi criada - verifique as configura√ß√µes de data e frequ√™ncia');
      }

      print(
          'üìä Total de sess√µes criadas: $sessionsCreated de $maxSessions calculadas');

      // Inserir todas as sess√µes de uma vez
      if (sessions.isNotEmpty) {
        final response = await SupabaseConfig.client
            .from('game_sessions')
            .insert(sessions)
            .select();

        print(
            '‚úÖ ${response.length} sess√µes recorrentes criadas para o jogo ${gameData['id']}');
        return response;
      } else {
        print(
            '‚ö†Ô∏è Nenhuma sess√£o foi criada - verifique as configura√ß√µes de data');
        // Retornar uma lista vazia em vez de lan√ßar erro
        return [];
      }
    } catch (e) {
      print('‚ùå Erro ao criar sess√µes recorrentes: $e');
      rethrow;
    }
  }

  /// Recria todas as sess√µes de um jogo (remove existentes e cria novas)
  static Future<Map<String, dynamic>> recreateGameSessions(
      String gameId, Map<String, dynamic> gameData) async {
    try {
      print('üîÑ Iniciando recria√ß√£o de sess√µes para o jogo $gameId...');

      // Verificar se o jogo n√£o est√° deletado
      final gameStatus = await _getGameStatus(gameId);
      if (gameStatus == 'deleted') {
        print('‚ùå N√£o √© poss√≠vel recriar sess√µes para um jogo deletado');
        return {
          'game_id': gameId,
          'success': false,
          'error': 'Jogo deletado',
          'message':
              'N√£o √© poss√≠vel recriar sess√µes para um jogo que foi deletado'
        };
      }

      // Remover todas as sess√µes existentes
      final removedCount = await removeAllGameSessions(gameId);

      // Criar novas sess√µes baseadas nos dados atuais
      final newSessions = await createNewSessions(gameData);

      print(
          '‚úÖ Recria√ß√£o conclu√≠da: $removedCount removidas, ${newSessions.length} criadas');

      return {
        'game_id': gameId,
        'removed_sessions': removedCount,
        'created_sessions': newSessions.length,
        'success': true,
        'message':
            'Sess√µes recriadas com sucesso: $removedCount removidas, ${newSessions.length} criadas'
      };
    } catch (e) {
      print('‚ùå Erro na recria√ß√£o de sess√µes: $e');
      return {
        'game_id': gameId,
        'success': false,
        'error': e.toString(),
        'message': 'Erro ao recriar sess√µes: $e'
      };
    }
  }

  /// Retorna o n√∫mero m√°ximo de sess√µes baseado na frequ√™ncia
  static int _getMaxSessionsForFrequency(String frequency,
      {DateTime? endDate, DateTime? startDate}) {
    // Se h√° data final, calcular baseado na diferen√ßa de datas
    if (endDate != null && startDate != null) {
      final daysDifference = endDate.difference(startDate).inDays;
      print(
          'üìä Diferen√ßa de dias entre ${_formatDate(startDate)} e ${_formatDate(endDate)}: $daysDifference dias');

      switch (frequency) {
        case 'Di√°ria':
          return daysDifference + 1; // Incluir o dia final
        case 'Semanal':
          return (daysDifference / 7).ceil() + 1; // Incluir a semana final
        case 'Mensal':
          return (daysDifference / 30).ceil() + 1; // Aproxima√ß√£o mensal
        case 'Anual':
          return (daysDifference / 365).ceil() + 1; // Aproxima√ß√£o anual
        default:
          return (daysDifference / 7).ceil() + 1; // Padr√£o semanal
      }
    }

    // Fallback para valores padr√£o se n√£o h√° data final
    print('‚ö†Ô∏è Usando valores padr√£o para frequ√™ncia: $frequency');
    switch (frequency) {
      case 'Di√°ria':
        return 30; // 1 m√™s
      case 'Semanal':
        return 52; // 1 ano
      case 'Mensal':
        return 12; // 1 ano
      case 'Anual':
        return 5; // 5 anos
      default:
        return 52; // Padr√£o: 1 ano
    }
  }

  /// Calcula a pr√≥xima data baseada na frequ√™ncia
  static DateTime _calculateNextDate(DateTime currentDate, String frequency) {
    switch (frequency) {
      case 'Di√°ria':
        return currentDate.add(const Duration(days: 1));
      case 'Semanal':
        return currentDate.add(const Duration(days: 7));
      case 'Mensal':
        // Lidar corretamente com meses de diferentes tamanhos
        int nextMonth = currentDate.month + 1;
        int nextYear = currentDate.year;
        if (nextMonth > 12) {
          nextMonth = 1;
          nextYear++;
        }

        // Verificar se o dia existe no pr√≥ximo m√™s
        int day = currentDate.day;
        int daysInNextMonth = DateTime(nextYear, nextMonth + 1, 0).day;
        if (day > daysInNextMonth) {
          day = daysInNextMonth;
        }

        return DateTime(nextYear, nextMonth, day);
      case 'Anual':
        return DateTime(
            currentDate.year + 1, currentDate.month, currentDate.day);
      default:
        return currentDate.add(const Duration(days: 7)); // Padr√£o semanal
    }
  }

  /// Converte dia da semana para n√∫mero (1=Segunda, 7=Domingo)
  /// Aceita tanto formato completo ('Quinta-feira') quanto abreviado ('Quinta')
  static int _getDayOfWeekNumber(String? dayName) {
    if (dayName == null) return 1; // Padr√£o: Segunda-feira

    // Normalizar o nome do dia (remover espa√ßos e converter para min√∫sculo)
    final normalizedDay = dayName.toLowerCase().trim();

    // Mapear formatos completos e abreviados
    switch (normalizedDay) {
      // Formato completo
      case 'segunda-feira':
      case 'segunda':
        return 1;
      case 'ter√ßa-feira':
      case 'ter√ßa':
        return 2;
      case 'quarta-feira':
      case 'quarta':
        return 3;
      case 'quinta-feira':
      case 'quinta':
        return 4;
      case 'sexta-feira':
      case 'sexta':
        return 5;
      case 's√°bado':
        return 6;
      case 'domingo':
        return 7;
      default:
        print(
            '‚ö†Ô∏è Dia da semana n√£o reconhecido: "$dayName" - usando Segunda-feira como padr√£o');
        return 1; // Padr√£o: Segunda-feira
    }
  }

  /// Calcula a pr√≥xima data v√°lida baseada no dia da semana e data de cria√ß√£o do jogo
  /// Se a data de cria√ß√£o √© o dia correto, retorna a data de cria√ß√£o
  /// Se n√£o, retorna a pr√≥xima ocorr√™ncia ap√≥s a data de cria√ß√£o
  static DateTime _calculateNextValidDate(int targetDayOfWeek,
      {DateTime? gameCreationDate}) {
    // Usar a data de cria√ß√£o do jogo como refer√™ncia, ou hoje se n√£o fornecida
    final referenceDate = gameCreationDate ?? DateTime.now();
    final referenceDay =
        DateTime(referenceDate.year, referenceDate.month, referenceDate.day);

    print('üìÖ C√°lculo da pr√≥xima data v√°lida:');
    print(
        '   Data de refer√™ncia: ${_formatDate(referenceDay)} (${_getDayName(referenceDay.weekday)})');
    print('   Dia alvo: ${_getDayName(targetDayOfWeek)}');

    // Se a data de refer√™ncia j√° √© o dia correto, usar ela
    if (referenceDay.weekday == targetDayOfWeek) {
      print(
          '   ‚úÖ A data de refer√™ncia √© o dia correto! Usando como primeira sess√£o.');
      return referenceDay;
    }

    // Se a data de refer√™ncia n√£o √© o dia correto, calcular a pr√≥xima ocorr√™ncia
    int daysToAdd = targetDayOfWeek - referenceDay.weekday;

    // Se o dia j√° passou na semana da data de refer√™ncia, ir para a pr√≥xima semana
    if (daysToAdd <= 0) {
      daysToAdd += 7;
    }

    final nextValidDate = referenceDay.add(Duration(days: daysToAdd));

    print(
        '   Pr√≥xima data: ${_formatDate(nextValidDate)} (${_getDayName(nextValidDate.weekday)})');

    return nextValidDate;
  }

  /// Retorna o nome do dia da semana baseado no n√∫mero
  static String _getDayName(int dayOfWeek) {
    switch (dayOfWeek) {
      case 1:
        return 'Segunda-feira';
      case 2:
        return 'Ter√ßa-feira';
      case 3:
        return 'Quarta-feira';
      case 4:
        return 'Quinta-feira';
      case 5:
        return 'Sexta-feira';
      case 6:
        return 'S√°bado';
      case 7:
        return 'Domingo';
      default:
        return 'Dia inv√°lido';
    }
  }

  /// Formata data para o formato YYYY-MM-DD
  static String _formatDate(DateTime date) {
    return '${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  /// Obt√©m o status de um jogo
  static Future<String?> _getGameStatus(String gameId) async {
    try {
      final response = await SupabaseConfig.client
          .from('games')
          .select('status')
          .eq('id', gameId)
          .maybeSingle();

      return response?['status'] as String?;
    } catch (e) {
      print('‚ùå Erro ao obter status do jogo: $e');
      return null;
    }
  }
}
